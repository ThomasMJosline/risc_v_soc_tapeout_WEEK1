
# Day 3
---
 
## 1. Logic Opitmizations

### **1. Combinational Logic Optimization**
Combinational logic is squeezed in order so as to save area and power consumption.

### **2. Undertanding the library filename**
The three important parameters regarding a device are:
 - Process
 - Voltage
 - Temperature
   
The .lib files are prepared for different cases of the above parameter. In our case the library used is:
### sky130_fd_sc_hd__tt_025C_1v80.lib 
 
Here the "tt_025c_1v80" part indicates the process, temperature and voltage parameters:
 - tt: Typical process corner.
 - 025C: the temparature range specified for this process is 25 degree celsius.
 -  1v80: the working voltage is 1.8V.

---

## 2. Exploring the .lib file
The sky130_fd_sc_hd__tt_025C_1v80.lib can be opened in some text editor. Here "gedit" is used:
```
$ gedit sky130_fd_sc_hd__tt_025C_1v80.lib 
```

<img src="images/lib_file.png" alt="Alt Text" width="500"/>


### Different versions of same logic

Here I have shown the two versions of 2 input and standard cells:
<div align="center">
  <img src="images/and_v0.png" width="500px" />
  <img src="images/and_v1.png" width="500px" />
</div>

Here it can be observed that the first cell has a leakage power less than that of the second one. This shows that the second cell is a faster version compared to the second one. It can be also seen that in the upcoming line of cell definition the first one will be have a lesser area than the second cell.

---

## 3. Hierarchical vs. Flattened Synthesis

When there are multiple modules involved in design there are two options of synthesizing the design
 - Hierarchical
 - Flattened

Here we us multiple_modules.v to demonstrate this

1. Heirarchical synthesis

The default synthesis generates heirarchical netlist

```
$ synth -top multiple_modules
```
Netlist generated during Heirarchical synthesis:

![Alt Text](images/show_heir_synth.png)

```verilog
module multiple_modules(a, b, c, y);
  input a;
  input b;
  input c;
  wire net1;
  output y;
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

module sub_module1(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  input a;
  input b;
  output y;
  sky130_fd_sc_hd__and2_2 _3_ (
    .A(_0_),
    .B(_1_),
    .X(_2_)
  );
  assign _0_ = b;
  assign _1_ = a;
  assign y = _2_;
endmodule

module sub_module2(a, b, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  wire _4_;
  input a;
  input b;
  output y;
  sky130_fd_sc_hd__clkinv_1 _5_ (
    .A(_0_),
    .Y(_3_)
  );
  sky130_fd_sc_hd__clkinv_1 _6_ (
    .A(_1_),
    .Y(_4_)
  );
  sky130_fd_sc_hd__nand2_1 _7_ (
    .A(_3_),
    .B(_4_),
    .Y(_2_)
  );
  assign _0_ = b;
  assign _1_ = a;
  assign y = _2_;
endmodule

```

2. Flattened synthesis

Inorder to convert the previously generated netlist to flattened mode:
```
$ flatten
```

Netlist corresponding to the flattened synthesis:

![Alt Text](images/show_flat_synth.png)

```verilog
/* Generated by Yosys 0.7 (git sha1 61f6811, gcc 6.2.0-11ubuntu1 -O2 -fdebug-prefix-map=/build/yosys-OIL3SR/yosys-0.7=. -fstack-protector-strong -fPIC -Os) */

module multiple_modules(a, b, c, y);
  wire _00_;
  wire _01_;
  wire _02_;
  wire _03_;
  wire _04_;
  wire _05_;
  wire _06_;
  wire _07_;
  input a;
  input b;
  input c;
  wire net1;
  wire \u1.a ;
  wire \u1.b ;
  wire \u1.y ;
  wire \u2.a ;
  wire \u2.b ;
  wire \u2.y ;
  output y;
  sky130_fd_sc_hd__and2_2 _08_ (
    .A(_00_),
    .B(_01_),
    .X(_02_)
  );
  sky130_fd_sc_hd__clkinv_1 _09_ (
    .A(_03_),
    .Y(_06_)
  );
  sky130_fd_sc_hd__clkinv_1 _10_ (
    .A(_04_),
    .Y(_07_)
  );
  sky130_fd_sc_hd__nand2_1 _11_ (
    .A(_06_),
    .B(_07_),
    .Y(_05_)
  );
  assign \u1.a  = a;
  assign \u1.b  = b;
  assign net1 = \u1.y ;
  assign _00_ = \u1.b ;
  assign _01_ = \u1.a ;
  assign \u1.y  = _02_;
  assign \u2.a  = net1;
  assign \u2.b  = c;
  assign y = \u2.y ;
  assign _03_ = \u2.b ;
  assign _04_ = \u2.a ;
  assign \u2.y  = _05_;
endmodule

```

In this netlist there are no instantiation of submodule. The top module is build directly from the standard cells.


For synthesising submodules:
```
synth -top submodule1
```
Here "submodule1" was one of the submodule in the main module "multiple_modules".
Need of synthesizing submodule:
 - If there are multiple instances of the same module. This can save time by avoiding synthesis of same module multiple times.
 - When there are large designs, it will be optimal to synthesis certain number of modules at a time and finish the synthesis of complete module(Divide and Conquer).

---

## 4. Using Flip-Flops in design

As the combiantional elements in the design introduce delay which are different for different elements, the output can have glitches. In order to prevent glitches from happening we need elements that can store values. This is why flip-flops are used in the design.

### 1. Flip-Flop with asynchronous reset

```verilog
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
 - Whenever the ```async_reset``` goes high the output is made 0, without waiting for the positive edge of the clock. Reset is not synchronised with the clock.
 - When no reseting the output is equal to the value of input at each positive edge of the clock.

### 2. Flip-Flop with synchronous reset

```verilog
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk )
begin
	if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
 - Resetting happens only at the first posedge of clock after ```sync_reset``` is made high.

---

## 5. Simulating and synthesis of flip-flops

### Simulation 

1. Compile design and testbench:
```
$ iverilog dff_asyncres.v tb_dff_asyncres.v
```
2. Run:
```
$ ./a.out
```
3. Observe the waveform:
```
$ gtkwave tb_dff_asyncres.vcd 
```
<div align="center">
  <img src="images/dff_async.png" width="800px" />
</div>

### Synthesis using Yosys

1. Start Yosys (from directory containing the design):
   ```
   $ yosys
   ```
2. Reading Liberty library:
   ```
   $ read_liberty -lib /address/to/your/sky130/file/sky130_fd_sc_hd__tt_025C_1v80.lib
   ```
3. Read verilog code of the Flip-Flop module:
   ```
   $ read_verilog dff_asyncres.v
   ```
4. Synthesize:
   ```
   $ synth -top dff_asyncres
   ```
   
5. Map the designs to the flip-flops in the library file:
   ```
   $ dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   ```
6. Technology mapping:
   ```
   $ abc -liberty /address/to/your/sky130/file/sky130_fd_sc_hd__tt_025C_1v80.lib
   ```
7. Observe the gate-level netlist:
   ```
   $ show
   ```
   
<div align="center">
  <img src="images/dff_async_net.png" width="800px" />
</div>

   In the netlist there is inverter. This is because the standard cell of Flip-Flop have active low reset, but our design implements a active high reset.

---
## 6. Implementing multiplication with 2 as shifting

<div align="center">
  <img src="images/mult2.png" width="800px" />
</div>

Here there is no any cell associated with the design, the multiplication by 2 operation is realized as left shift by 1.

---

